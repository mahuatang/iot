package com.soco.car.iot.server.app.handler;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.soco.car.iot.constants.AppChannelContext;
import com.soco.car.iot.constants.DeviceChannelContext;
import com.soco.car.iot.constants.SOCOIotConstant;
import com.soco.car.iot.server.car.message.MessageConverterContext;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

@Service("appChannelInboundHandler")
@Sharable
public class AppChannelInboundHandler extends ChannelInboundHandlerAdapter {

	private static final Logger logger = LoggerFactory.getLogger(AppChannelInboundHandler.class);

	@Autowired
	private MessageConverterContext messageConverterContext;

	@Override
	public void channelActive(ChannelHandlerContext ctx) throws Exception {
		SOCOIotConstant.online_app_number.increment();
		logger.info("在线APP总数为:" + SOCOIotConstant.online_app_number.intValue());
		super.channelActive(ctx);
	}

	/**
	 * 
	 * channelInactive: tcp连接通道超时或主动断开
	 *
	 * @author sunlangping
	 * @param ctx
	 * @throws Exception
	 */
	@Override
	public void channelInactive(ChannelHandlerContext ctx) throws Exception {
		SOCOIotConstant.online_app_number.decrement();
		super.channelInactive(ctx);
		String deviceNo = DeviceChannelContext.removeAttrbute(ctx.channel());
		logger.info("连接断开,设备ID为:{},在线APP总数为:{}", deviceNo, SOCOIotConstant.online_app_number.intValue());
		if (StringUtils.isNotEmpty(deviceNo)) {
			DeviceChannelContext.removeDevice(deviceNo);
		}
	}

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object obj) throws Exception {
		ByteBuf msg = (ByteBuf) obj;
		// int len = msg.readInt();
		// logger.info("消息的长度为:{}", len);
		Channel channel = ctx.channel();
		byte[] byteMsg = new byte[msg.readableBytes()];
		String app = AppChannelContext.getAttrbute(channel);
		msg.readBytes(byteMsg);

		String message = new String(byteMsg, SOCOIotConstant.default_charset_utf8);
		logger.info("message:{}", message);
	}

	/**
	 * 
	 * 超时时触发
	 * 
	 * @see io.netty.channel.ChannelInboundHandlerAdapter#userEventTriggered(io.netty.channel.ChannelHandlerContext,
	 *      java.lang.Object)
	 */
	@Override
	public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
		super.userEventTriggered(ctx, evt);
		ctx.close();
		// Channel channel = ctx.channel();
		// if (!channel.isOpen()) {
		// }
		// if (evt instanceof IdleStateEvent) {
		//
		// IdleStateEvent event = (IdleStateEvent) evt;
		//
		// if (event.state().equals(IdleState.READER_IDLE)) { // 读超时
		// // 超时关闭channel
		//// ctx.close();
		// checkHeartbeatMsg(ctx, channel);
		// } else if (event.state().equals(IdleState.WRITER_IDLE)) {// 写超时
		// checkHeartbeatMsg(ctx, channel);
		// } else if (event.state().equals(IdleState.ALL_IDLE)) {// 读写超时
		// checkHeartbeatMsg(ctx, channel);
		// }
		// }
	}

	/**
	 * 
	 * checkHeartbeatMsg:
	 * 检查客户端是否还连接服务器，如果连接服务器状态，服务器端超时则主动发客户端发心跳包，此方法目前占不使用，降低服务器压力
	 *
	 * @author sunlangping
	 * @param ctx
	 * @param channel
	 */
	@Deprecated
	private void checkHeartbeatMsg(ChannelHandlerContext ctx, Channel channel) {
		// 检测到过期主动发送服务器端心跳
		ByteBuf bf = Unpooled.copiedBuffer(new byte[] { 0x01 });
		if (channel.isOpen()) {
			channel.writeAndFlush(bf);
		} else {
			ctx.close();
		}
	}

	/**
	 * 
	 * 服务器端未给客户端回复,客户端提前关闭
	 * 
	 * @see io.netty.channel.ChannelInboundHandlerAdapter#exceptionCaught(io.netty.channel.ChannelHandlerContext,
	 *      java.lang.Throwable)
	 */
	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
		super.exceptionCaught(ctx, cause);
		Channel channel = ctx.channel();
		if (channel.isActive()) {
			ctx.close();
		}
	}

}
